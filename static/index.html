<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>GitHub Repo Analyzer</title>
</head>

<body>
    <h1>GitHub Repo Analyzer</h1>
    <input type="text" id="repo-url" placeholder="Enter GitHub repo URL">
    <button onclick="fetchCommits()">Submit</button>
    <pre id="output"></pre>

    <script>
        function fetchCommits() {
            const repoUrl = document.getElementById('repo-url').value;
            const outputElement = document.getElementById('output');

            if (!repoUrl) {
                outputElement.textContent = "Please enter a valid GitHub repo URL.";
                return;
            }

            fetch(`/clone?url=${encodeURIComponent(repoUrl)}`)
                .then(response => response.json())
                .then(data => {
                    outputElement.textContent = JSON.stringify(data, null, 2);
                })
                .catch(error => {
                    outputElement.textContent = `Error: ${error}`;
                });
        }
    </script>
    <script type="module">
        // THIS IS GIGACRINGE, inline this with webpack or some shit ughhhhhhhhhhhh i just want syntax highlighting
        async function loadWGSL(name) {
            const response = await fetch('/' + name);
            return await response.text();
        }

        async function initWebGPU() {
            const canvas = document.querySelector("canvas");

            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }
            const device = await adapter.requestDevice();

            const doubleWGSL = await loadWGSL('double.wgsl');

            const module = device.createShaderModule({
                label: 'doubling compute module',
                code: doubleWGSL,
            });

            const pipeline = device.createComputePipeline({
                label: 'doubling compute pipeline',
                layout: 'auto',
                compute: {
                    module,
                },
            });

            const input = new Float32Array([1, 3, 5]);

            // create a buffer on the GPU to hold our computation
            // input and output
            const workBuffer = device.createBuffer({
                label: 'work buffer',
                size: input.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
            });
            // Copy our input data to that buffer
            device.queue.writeBuffer(workBuffer, 0, input);

            // create a buffer on the GPU to get a copy of the results
            const resultBuffer = device.createBuffer({
                label: 'result buffer',
                size: input.byteLength,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
            });

            // Setup a bindGroup to tell the shader which
            // buffer to use for the computation
            const bindGroup = device.createBindGroup({
                label: 'bindGroup for work buffer',
                layout: pipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: workBuffer } },
                ],
            });

            console.log('input', input);

            for (let n = 0; n < 3; n++) {
                // Encode commands to do the computation
                const encoder = device.createCommandEncoder({
                    label: 'doubling encoder',
                });
                for (let i = 0; i < 5; i++) {
                    const pass = encoder.beginComputePass({
                        label: 'doubling compute pass',
                    });
                    pass.setPipeline(pipeline);
                    pass.setBindGroup(0, bindGroup);
                    pass.dispatchWorkgroups(input.length);
                    pass.end();
                }

                // Encode a command to copy the results to a mappable buffer.
                encoder.copyBufferToBuffer(workBuffer, 0, resultBuffer, 0, resultBuffer.size);

                // Finish encoding and submit the commands
                const commandBuffer = encoder.finish();
                device.queue.submit([commandBuffer]);


                // Read the results
                await resultBuffer.mapAsync(GPUMapMode.READ);
                const result = new Float32Array(resultBuffer.getMappedRange());

                console.log('result', result);

                resultBuffer.unmap();
            }
        }

        async function initWebGPU2() {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }
            const device = await adapter.requestDevice();

            const updateCoordsWGSL = await loadWGSL('update_coords.wgsl');

            const module = device.createShaderModule({
                label: 'coord update compute module',
                code: updateCoordsWGSL,
            });

            const pipeline = device.createComputePipeline({
                label: 'coord update compute pipeline',
                layout: 'auto',
                compute: {
                    module,
                },
            });


            const N = 5;
            const coords = new Float32Array(N * 2).map(() => Math.random());
            const distMatrix = new Float32Array(N * N).map(() => Math.random());

            // create a buffer on the GPU to hold our computation
            // input and output
            const coordBuffer = device.createBuffer({
                label: 'coord buffer',
                size: coords.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
            });
            // Copy our input data to that buffer
            device.queue.writeBuffer(coordBuffer, 0, coords);

            const distMatrixBuffer = device.createBuffer({
                label: 'dist matrix buffer',
                size: distMatrix.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST, // TODO: ??
            });
            device.queue.writeBuffer(distMatrixBuffer, 0, distMatrix);

            const paramsBuffer = device.createBuffer({
                label: 'params buffer',
                size: 16,  // size of Params struct; TODO: ?????
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
            });

            // create a buffer on the GPU to get a copy of the results
            const resultBuffer = device.createBuffer({
                label: 'result buffer',
                size: coords.byteLength,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
            });

            // Setup a bindGroup to tell the shader which
            // buffer to use for the computation
            const bindGroup = device.createBindGroup({
                label: 'bindGroup for work buffer',
                layout: pipeline.getBindGroupLayout(0),
                // entries: [
                //     { binding: 0, resource: { buffer: workBuffer } },
                // ],
                entries: [
                    { binding: 0, resource: { buffer: coordBuffer } },
                    { binding: 1, resource: { buffer: distMatrixBuffer } },
                    { binding: 2, resource: { buffer: paramsBuffer } },
                ],
            });

            console.log('before', coords.toString());

            for (let batch = 0; batch < 10; batch++) {
                const encoder = device.createCommandEncoder({
                    label: 'coord update encoder',
                });

                for (let iteration = 0; iteration < 5000; iteration++) {
                    let pivotIdx = Math.floor(Math.random() * N);
                    let learningRate = 0.001

                    const params = new Float32Array([pivotIdx, learningRate, N, 0]); // TODO: ??
                    device.queue.writeBuffer(paramsBuffer, 0, params.buffer);

                    const pass = encoder.beginComputePass({
                        label: 'coord update compute pass',
                    });
                    pass.setPipeline(pipeline);
                    pass.setBindGroup(0, bindGroup);
                    pass.dispatchWorkgroups(N);
                    pass.end();
                }

                encoder.copyBufferToBuffer(coordBuffer, 0, resultBuffer, 0, coordBuffer.size);

                // Finish encoding and submit the commands
                const commandBuffer = encoder.finish();
                device.queue.submit([commandBuffer]);

                // Read the results
                await resultBuffer.mapAsync(GPUMapMode.READ);
                const result = new Float32Array(resultBuffer.getMappedRange());

                console.log('result', result.toString());

                resultBuffer.unmap();
            }
        }

        initWebGPU2();
    </script>

</body>

</html>