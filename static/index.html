<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>GitHub Repo Analyzer</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>

<body>
    <h1>GitHub Repo Analyzer</h1>
    <input type="text" id="repo-url" placeholder="Enter GitHub repo URL" value="https://github.com/elixir-lang/elixir">
    <button onclick="fetchCommits()">Submit</button>
    <pre id="output"></pre>
    <div id="plot"></div> <!-- Add a div for the plot -->
    <canvas style="display: none;"></canvas> <!-- Hidden canvas for WebGPU -->

    <script>
        function fetchCommits() {
            initWebGPU2()
            return;

            const repoUrl = document.getElementById('repo-url').value;
            const outputElement = document.getElementById('output');

            if (!repoUrl) {
                outputElement.textContent = "Please enter a valid GitHub repo URL.";
                return;
            }

            fetch(`/clone?url=${encodeURIComponent(repoUrl)}`)
                .then(response => response.json())
                .then(data => {
                    // outputElement.textContent = JSON.stringify(data, null, 2);
                    initWebGPU2(data);
                })
                .catch(error => {
                    outputElement.textContent = `Error: ${error}`;
                });
        }

        async function loadWGSL(name) {
            const response = await fetch('/' + name);
            return await response.text();
        }

        function jaccardSimilarity(set1, set2) {
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            return intersection.size / union.size;
        }

        async function initWebGPU2(commitMap) {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }
            const device = await adapter.requestDevice();

            const updateCoordsWGSL = await loadWGSL('update_coords.wgsl');
            console.log(updateCoordsWGSL)

            const module = device.createShaderModule({
                label: 'coord update compute module',
                code: updateCoordsWGSL,
            });

            const pipeline = device.createComputePipeline({
                label: 'coord update compute pipeline',
                layout: 'auto',
                compute: {
                    module,
                },
            });


            // Create the distance matrix

            console.log("starting matrix")

            // const files = Object.keys(commitMap);
            // const N = files.length;

            // console.log("N IS", N)

            const N = 100
            const distMatrix = new Float32Array(N * N);
            // for (let i = 0; i < N; i++) {
            //     for (let j = 0; j < N; j++) {
            //         if (i === j) {
            //             distMatrix[i * N + j] = 0;
            //         } else {
            //             const set1 = new Set(commitMap[files[i]]);
            //             const set2 = new Set(commitMap[files[j]]);
            //             distMatrix[i * N + j] = 1 - jaccardSimilarity(set1, set2);
            //         }
            //     }
            // }
            distMatrix.map(() => 1)

            console.log("matrix done")

            const coords = new Float32Array(N * 2).map(() => Math.random());

            const coordBuffer = device.createBuffer({
                label: 'coord buffer',
                size: coords.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
            });

            device.queue.writeBuffer(coordBuffer, 0, coords);

            const distMatrixBuffer = device.createBuffer({
                label: 'dist matrix buffer',
                size: distMatrix.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(distMatrixBuffer, 0, distMatrix);

            params = new Float32Array([69, 0.01, N, 0]);
            const paramsBuffer = device.createBuffer({
                label: 'params buffer',
                // size: 16,  // size of Params struct
                size: params.byteLength,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(paramsBuffer, 0, params)

            const resultBuffer = device.createBuffer({
                label: 'result buffer',
                size: coords.byteLength,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
            });

            const bindGroup = device.createBindGroup({
                label: 'bindGroup for work buffer',
                layout: pipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: coordBuffer } },
                    { binding: 1, resource: { buffer: distMatrixBuffer } },
                    { binding: 2, resource: { buffer: paramsBuffer } },
                ],
            });

            console.log('before', coords.toString());

            // for (let batch = 0; batch < 20; batch++) {
            //     const encoder = device.createCommandEncoder({
            //         label: 'coord update encoder',
            //     });

            //     let pivotIdx = Math.floor(Math.random() * N);
            //     console.log("idx:", pivotIdx)

            //     for (let iteration = 0; iteration < 1; iteration++) {
            //         // let pivotIdx = Math.floor(Math.random() * N);
            //         let learningRate = 0.01

            //         const params = new Float32Array([pivotIdx, learningRate, N, 0]);
            //         device.queue.writeBuffer(paramsBuffer, 0, params);

            //         const pass = encoder.beginComputePass({
            //             label: 'coord update compute pass',
            //         });
            //         pass.setPipeline(pipeline);
            //         pass.setBindGroup(0, bindGroup);
            //         pass.dispatchWorkgroups(N);
            //         pass.end();
            //     }

            //     encoder.copyBufferToBuffer(coordBuffer, 0, resultBuffer, 0, coordBuffer.size);

            //     const commandBuffer = encoder.finish();
            //     device.queue.submit([commandBuffer]);

            //     await resultBuffer.mapAsync(GPUMapMode.READ);
            //     const result = new Float32Array(resultBuffer.getMappedRange());

            //     console.log('result', result.toString());
            //     console.log("pos at idx:", result[2 * pivotIdx], result[2 * pivotIdx + 1])
            //     plotPoints(result);

            //     resultBuffer.unmap();
            // }

            for (let batch = 0; batch < 10000; batch++) {
                // let pivotIdx = Math.floor(Math.random() * N);
                // console.log("idx is", pivotIdx)
                // let learningRate = 0.1
                // const params = new Float32Array([pivotIdx, learningRate, N, pivotIdx]);
                // device.queue.writeBuffer(paramsBuffer, 0, params);

                const encoder = device.createCommandEncoder({
                    label: 'coord update encoder',
                });
                const pass = encoder.beginComputePass({
                    label: 'coord update compute pass',
                });
                pass.setPipeline(pipeline);
                pass.setBindGroup(0, bindGroup);
                pass.dispatchWorkgroups(N);
                pass.end();

                // encoder.copyBufferToBuffer(coordBuffer, 0, resultBuffer, 0, coordBuffer.size);

                const commandBuffer = encoder.finish();

                device.queue.submit([commandBuffer]);
            }

            // print results
            {
                const encoder = device.createCommandEncoder({
                    label: 'coord update encoder',
                });
                // const pass = encoder.beginComputePass({
                //     label: 'coord update compute pass',
                // });
                // pass.setPipeline(pipeline);
                // pass.setBindGroup(0, bindGroup);
                // pass.dispatchWorkgroups(N);
                // pass.end();

                encoder.copyBufferToBuffer(coordBuffer, 0, resultBuffer, 0, coordBuffer.size);

                const commandBuffer = encoder.finish();
                device.queue.submit([commandBuffer]);

                await resultBuffer.mapAsync(GPUMapMode.READ);
                const result = new Float32Array(resultBuffer.getMappedRange());

                console.log('result', result.toString());

                console.log("pos0: ", result[0], result[1])

                plotPoints(result);

                resultBuffer.unmap();

            }

        }

        function plotPoints(coords) {
            const x = [];
            const y = [];
            const text = [];

            for (let i = 0; i < coords.length; i += 2) {
                x.push(coords[i]);
                y.push(coords[i + 1]);
                text.push((i / 2).toString());  // logical index
            }

            const trace = {
                x: x,
                y: y,
                mode: 'markers',
                type: 'scatter',
                text: text,
                hoverinfo: 'text',
            };

            const data = [trace];

            Plotly.newPlot('plot', data);
        }
    </script>

</body>

</html>