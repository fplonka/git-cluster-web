<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>GitHub Repo Analyzer</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
        }

        #plot {
            height: 100%;
            width: 100%;
            background-color: lightgray;
        }
    </style>
</head>

<body>
    <h1>GitHub Repo Analyzer</h1>
    <input type="text" id="repo-url" placeholder="Enter GitHub repo URL" value="https://github.com/elixir-lang/elixir">
    <button onclick="fetchCommits()">Submit</button>
    <div id="output"></div>
    <div id="plot"></div> <!-- Add a div for the plot -->
    <canvas style="display: none;"></canvas> <!-- Hidden canvas for WebGPU -->

    <script>
        function fetchCommits() {
            const repoUrl = document.getElementById('repo-url').value;
            const outputElement = document.getElementById('output');

            if (!repoUrl) {
                outputElement.textContent = "Please enter a valid GitHub repo URL.";
                return;
            }

            outputElement.textContent = "Cloning repo...";

            fetch(`/clone?url=${encodeURIComponent(repoUrl)}`)
                .then(response => response.json())
                .then(data => {
                    // outputElement.textContent = JSON.stringify(data, null, 2);
                    initWebGPU2(data);
                })
                .catch(error => {
                    outputElement.textContent = `Error: ${error}`;
                });
        }

        async function loadWGSL(name) {
            const response = await fetch('/' + name);
            return await response.text();
        }

        function jaccardSimilarity(set1, set2) {
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            return intersection.size / union.size;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function computeDistanceMatrix(commitMap) {
            console.log("starting on matrix")
            const outputElement = document.getElementById('output');

            const files = Object.keys(commitMap);
            const N = files.length;
            const distMatrix = new Float32Array(N * N);

            // Precompute sets for each file
            const sets = files.map(file => new Set(commitMap[file]));

            // Precompute set sizes
            const setSizes = sets.map(set => set.size);

            for (let i = 0; i < N; i++) {
                if (i % 200 === 0) {
                    console.log("Processed", i);
                    outputElement.textContent = `computing distance matrix: ${(N * i - (0.5 * i * (i + 1))) / (0.5 * N * (N - 1)) * 100}%` // TODO: math wrong

                    // beyond cursed; without this the browser is too overwhelmed to update the text....
                    await new Promise(r => setTimeout(r, 1));

                    // outputElement.textContent = `computing distance matrix: ${i / N * 100}%`
                }
                for (let j = i + 1; j < N; j++) {
                    const set1 = sets[i];
                    const set2 = sets[j];

                    const intersectionSize = [...set1].filter(x => set2.has(x)).length;
                    const unionSize = setSizes[i] + setSizes[j] - intersectionSize;
                    const similarity = intersectionSize / unionSize;

                    const distance = 1 - similarity;
                    distMatrix[i * N + j] = distance;
                    distMatrix[j * N + i] = distance;
                }
                distMatrix[i * N + i] = 0;
            }

            console.log("matrix done");
            return distMatrix;
        }

        async function computeDistanceMatrixRowByRow(commitMap, device, distMatrixBuffer) {
            console.log("starting on matrix");
            const outputElement = document.getElementById('output');

            const files = Object.keys(commitMap);
            const N = files.length;

            // Precompute sets for each file
            const sets = files.map(file => new Set(commitMap[file]));

            // Precompute set sizes
            const setSizes = sets.map(set => set.size);

            // Create a temporary buffer for a single row
            const rowBuffer = new Float32Array(N);

            for (let i = 0; i < N; i++) {
                if (i % 200 === 0) {
                    console.log("Processed", i);
                    outputElement.textContent = `computing distance matrix: ${(N * i - (0.5 * i * (i + 1))) / (0.5 * N * (N - 1)) * 100}%`;

                    // Update the UI to avoid browser freezing
                    await new Promise(r => setTimeout(r, 1));
                }

                for (let j = 0; j < N; j++) {
                    if (i === j) {
                        rowBuffer[j] = 0;
                    } else {
                        const set1 = sets[i];
                        const set2 = sets[j];

                        const intersectionSize = [...set1].filter(x => set2.has(x)).length;
                        const unionSize = setSizes[i] + setSizes[j] - intersectionSize;
                        const similarity = intersectionSize / unionSize;

                        const distance = 1 - similarity;
                        rowBuffer[j] = distance;
                    }
                }

                // Write the current row to the GPU buffer
                device.queue.writeBuffer(distMatrixBuffer, i * N * rowBuffer.BYTES_PER_ELEMENT, rowBuffer.buffer);
            }

            console.log("matrix done");
        }

        function generateRandomExtensions(N) {
            const extensions = ['.cpp', '.py'];
            let result = [];

            for (let i = 0; i < N; i++) {
                const randomIndex = Math.floor(Math.random() * extensions.length);
                result.push(extensions[randomIndex]);
            }

            return result;
        }

        async function initWebGPU2(commitMap) {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }

            let N = Object.keys(commitMap).length;
            console.log("max buffer size:", adapter.limits.maxBufferSize)
            console.log("max storage buffer binding size:", adapter.limits.maxStorageBufferBindingSize)
            // 4*N*N for the distance matrix buffer
            const requiredMemory = Math.min(4 * N * N, adapter.limits.maxBufferSize, adapter.limits.maxStorageBufferBindingSize)
            const required_limits = {};
            // https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/limits
            required_limits.maxStorageBufferBindingSize = requiredMemory;
            required_limits.maxBufferSize = requiredMemory;
            const device = await adapter.requestDevice({
                "requiredLimits": required_limits
            });

            // remove random entries from commits until the number of keys N satisfies 4*N*N <= requiredMemory
            const keys = Object.keys(commitMap);
            if (4 * keys.length * keys.length > requiredMemory) {
                console.warn("have to drop entries...")
            }
            while (4 * keys.length * keys.length > requiredMemory) {
                const randomIndex = Math.floor(Math.random() * keys.length);
                const keyToRemove = keys[randomIndex];
                delete commitMap[keyToRemove];
                keys.splice(randomIndex, 1);
            }


            const filenames = Object.keys(commitMap);
            N = Object.keys(commitMap).length;
            console.log("N IS", N)
            console.log("NEED:", requiredMemory)

            const fileExtensions = filenames.map(filename => {
                const baseName = filename.split('/').pop()
                const dotIndex = baseName.lastIndexOf('.');
                let extension = dotIndex !== -1 ? baseName.slice(dotIndex) : 'no_extension';
                if (extension.length > 20) {
                    extension = extension.substring(0, 20) + "...";
                }
                return extension;

            });

            let coords = new Float32Array(N * 2).map(() => Math.random());

            const updateCoordsWGSL = await loadWGSL('update_coords.wgsl');

            const module = device.createShaderModule({
                label: 'coord update compute module',
                code: updateCoordsWGSL,
            });

            const pipeline = device.createComputePipeline({
                label: 'coord update compute pipeline',
                layout: 'auto',
                compute: {
                    module,
                },
            });

            const coordBuffer = device.createBuffer({
                label: 'coord buffer',
                size: coords.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
            });

            device.queue.writeBuffer(coordBuffer, 0, coords);

            const distMatrixBuffer = device.createBuffer({
                label: 'dist matrix buffer',
                size: 4 * N * N,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
            });
            await computeDistanceMatrixRowByRow(commitMap, device, distMatrixBuffer);

            // device.queue.writeBuffer(distMatrixBuffer, 0, distMatrix);

            const resultBuffer = device.createBuffer({
                label: 'result buffer',
                size: coords.byteLength,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
            });

            initial_lr = 0.01
            // final_lr = 0.0000001
            final_lr = 0.00001
            iterations_done = 0
            num_iters = 2_000_000
            iterations_in_batch = 1
            max_iterations_in_batch = 100_000

            var startTime = performance.now()

            paramBuffers = []
            bindGroups = []
            for (let i = 0; i < max_iterations_in_batch; i++) {
                const buffer = device.createBuffer({
                    label: `uniforms for iteration ${i}`,
                    size: 16,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });
                paramBuffers.push(buffer)

                const bindGroup = device.createBindGroup({
                    label: `bind group for iteration ${i}`,
                    layout: pipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: coordBuffer } },
                        { binding: 1, resource: { buffer: distMatrixBuffer } },
                        { binding: 2, resource: { buffer: buffer } },
                    ],
                });
                bindGroups.push(bindGroup)

            }

            const outputElement = document.getElementById('output');
            const paramsArrayBuffer = new ArrayBuffer(16); // 4 * 4 bytes
            const dataView = new DataView(paramsArrayBuffer);
            dataView.setUint32(8, N, true);                 // Set N as u32 at offset 8
            while (iterations_done < num_iters) {
                console.log("at", iterations_done)
                outputElement.textContent = `computing embeddings: ${iterations_done / num_iters * 100}%`
                for (let i = 0; i < iterations_in_batch; i++) {
                    const pivotIdx = Math.floor(Math.random() * N);
                    const lr = final_lr + 0.5 * (initial_lr - final_lr) * (1 + Math.cos(Math.PI * (iterations_done + i) / num_iters));
                    dataView.setUint32(0, pivotIdx, true);
                    dataView.setFloat32(4, lr, true);
                    device.queue.writeBuffer(paramBuffers[i], 0, paramsArrayBuffer);
                }

                const encoder = device.createCommandEncoder({
                    label: 'coord update encoder',
                });
                const pass = encoder.beginComputePass({
                    label: 'coord update compute pass',
                });
                pass.setPipeline(pipeline);
                for (let i = 0; i < iterations_in_batch && iterations_done < num_iters; i++) {
                    pass.setBindGroup(0, bindGroups[i]);
                    pass.dispatchWorkgroups(N);
                    iterations_done++
                }
                iterations_in_batch = Math.min(1.2 * iterations_in_batch, max_iterations_in_batch)
                pass.end();

                encoder.copyBufferToBuffer(coordBuffer, 0, resultBuffer, 0, coordBuffer.size);

                const commandBuffer = encoder.finish();

                device.queue.submit([commandBuffer]);

                // and now display results
                await resultBuffer.mapAsync(GPUMapMode.READ);
                const result = new Float32Array(resultBuffer.getMappedRange());

                plotPoints(result, fileExtensions, filenames);
                resultBuffer.unmap();
            }

            var endTime = performance.now()

            console.log(`Took ${endTime - startTime} milliseconds`)
            console.log("ALL DONE")
        }

        function plotPoints(coords, extensions, fileNames) {
            const extensionColors = getExtensionColors(extensions);

            const traces = [];
            const colorMapping = {};

            // Prepare data for each extension
            for (const [ext, color] of Object.entries(extensionColors)) {
                const indices = [];
                for (let i = 0; i < extensions.length; i++) {
                    if (extensions[i] === ext) {
                        indices.push(i);
                    }
                }

                if (indices.length > 0) {
                    const x = indices.map(i => coords[2 * i]);
                    const y = indices.map(i => coords[2 * i + 1]);
                    const text = indices.map(i => fileNames[i]);

                    const trace = {
                        x: x,
                        y: y,
                        mode: 'markers',
                        type: 'scattergl',
                        text: text,
                        hoverinfo: 'text',
                        marker: {
                            size: 5,
                            color: color,
                            opacity: 0.8
                        },
                        name: ext
                    };
                    traces.push(trace);
                }
            }

            const layout = {
                title: 'File Commit-Similarity Visualization',
                xaxis: { title: 'MDS Dimension 1', constrain: 'domain' },
                yaxis: { title: 'MDS Dimension 2', scaleanchor: 'x', scaleratio: 1 },
                hovermode: 'closest',
                paper_bgcolor: 'white',
                plot_bgcolor: 'rgba(240,240,240,1)',
                legend: { orientation: 'v' }
            };

            Plotly.newPlot('plot', traces, layout);

            window.onresize = function () {
                Plotly.Plots.resize(document.getElementById('plot'));
            };
        }

        function getExtensionColors(extensions) {
            // Count files for each extension
            const extCount = {};
            extensions.forEach(ext => {
                if (!extCount[ext]) {
                    extCount[ext] = 0;
                }
                extCount[ext] += 1
            });

            // Sort extensions by count
            const sortedExtensions = Object.keys(extCount).sort((a, b) => extCount[b] - extCount[a]);

            // Use a Plotly color sequence
            const colorSequence = ['#636EFA', '#EF553B', '#00CC96', '#AB63FA', '#FFA15A', '#19D3F3',
                '#FF6692', '#B6E880', '#FF97FF', '#FECB52']

            const extensionColors = {};
            sortedExtensions.forEach((ext, i) => {
                extensionColors[ext] = colorSequence[i % colorSequence.length];
            });

            return extensionColors;
        }
    </script>

</body>

</html>